"""
Advanced Malware Detection Engine with YARA Rules Integration
Next-generation malware analysis and automated detection capabilities.
"""

import os
import hashlib
import json
import requests
import tempfile
import subprocess
import threading
from datetime import datetime, timedelta
from typing import List, Dict, Tuple, Optional, Set, Union
from collections import defaultdict, Counter
from dataclasses import dataclass
import concurrent.futures
import magic
import pefile
import oletools.olevba
import zipfile
import rarfile
import tarfile
import re

# Try to import yara, fallback if not available
try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    print("YARA not available. Install python-yara for full malware detection capabilities.")

# Try to import additional malware analysis libraries
try:
    import volatility3
    VOLATILITY_AVAILABLE = True
except ImportError:
    VOLATILITY_AVAILABLE = False

try:
    import capa
    CAPA_AVAILABLE = True
except ImportError:
    CAPA_AVAILABLE = False

@dataclass
class MalwareDetection:
    """Malware detection result with detailed analysis."""
    file_path: str
    file_hash: str
    malware_family: Optional[str] = None
    threat_name: str = ""
    confidence: float = 0.0
    severity: str = "LOW"  # LOW, MEDIUM, HIGH, CRITICAL
    detection_methods: List[str] = None
    yara_matches: List[Dict] = None
    behavioral_indicators: List[str] = None
    static_analysis: Dict = None
    dynamic_analysis: Dict = None
    attribution: Optional[str] = None
    iocs: List[str] = None
    mitigation: List[str] = None

    def __post_init__(self):
        if self.detection_methods is None:
            self.detection_methods = []
        if self.yara_matches is None:
            self.yara_matches = []
        if self.behavioral_indicators is None:
            self.behavioral_indicators = []
        if self.static_analysis is None:
            self.static_analysis = {}
        if self.dynamic_analysis is None:
            self.dynamic_analysis = {}
        if self.iocs is None:
            self.iocs = []
        if self.mitigation is None:
            self.mitigation = []


class AdvancedMalwareDetector:
    """Advanced malware detection engine with multiple analysis techniques."""
    
    def __init__(self):
        self.yara_rules = []
        self.compiled_rules = None
        self.malware_signatures = {}
        self.threat_intelligence = {}
        self.analysis_cache = {}
        self.sandbox_results = {}
        
        # Initialize malware detection components
        self._initialize_yara_rules()
        self._load_malware_signatures()
        self._setup_threat_intelligence()
        
    def analyze_file(self, file_path: str, deep_analysis: bool = True) -> MalwareDetection:
        """
        Perform comprehensive malware analysis on a file.
        
        Args:
            file_path: Path to file for analysis
            deep_analysis: Whether to perform deep analysis (slower but more thorough)
            
        Returns:
            MalwareDetection object with analysis results
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File not found: {file_path}")
        
        # Calculate file hash for caching
        file_hash = self._calculate_file_hash(file_path)
        
        # Check cache first
        if file_hash in self.analysis_cache:
            return self.analysis_cache[file_hash]
        
        # Initialize detection result
        detection = MalwareDetection(
            file_path=file_path,
            file_hash=file_hash
        )
        
        try:
            # Multi-threaded analysis for performance
            with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:
                futures = []
                
                # YARA rule matching
                if YARA_AVAILABLE and self.compiled_rules:
                    futures.append(executor.submit(self._yara_scan, file_path))
                
                # Static analysis
                futures.append(executor.submit(self._static_analysis, file_path))
                
                # Entropy analysis
                futures.append(executor.submit(self._entropy_analysis, file_path))
                
                # String analysis
                futures.append(executor.submit(self._string_analysis, file_path))
                
                # PE analysis (if applicable)
                futures.append(executor.submit(self._pe_analysis, file_path))
                
                # Behavioral pattern matching
                futures.append(executor.submit(self._behavioral_analysis, file_path))
                
                # Collect results
                for future in concurrent.futures.as_completed(futures):
                    try:
                        result = future.result()
                        if result:
                            self._merge_detection_results(detection, result)
                    except Exception as e:
                        print(f"Error in malware analysis component: {e}")
            
            # Deep analysis if requested
            if deep_analysis:
                self._perform_deep_analysis(detection)
            
            # Calculate overall confidence and severity
            self._calculate_detection_confidence(detection)
            
            # Generate IOCs and mitigation strategies
            self._generate_iocs(detection)
            self._generate_mitigation_strategies(detection)
            
            # Cache result
            self.analysis_cache[file_hash] = detection
            
        except Exception as e:
            detection.threat_name = f"Analysis Error: {str(e)}"
            detection.confidence = 0.0
        
        return detection
    
    def analyze_memory_artifacts(self, memory_analysis: Dict) -> List[MalwareDetection]:
        """Analyze memory artifacts for malware indicators."""
        detections = []
        
        if 'processes' in memory_analysis:
            for process in memory_analysis['processes']:
                detection = self._analyze_process_for_malware(process)
                if detection and detection.confidence > 0.3:
                    detections.append(detection)
        
        if 'network_connections' in memory_analysis:
            network_detections = self._analyze_network_connections(memory_analysis['network_connections'])
            detections.extend(network_detections)
        
        return detections
    
    def scan_directory(self, directory_path: str, recursive: bool = True, 
                      file_extensions: Optional[List[str]] = None) -> List[MalwareDetection]:
        """
        Scan a directory for malware.
        
        Args:
            directory_path: Directory to scan
            recursive: Whether to scan subdirectories
            file_extensions: List of file extensions to scan (None for all)
            
        Returns:
            List of MalwareDetection objects for suspicious files
        """
        detections = []
        
        # Default suspicious file extensions
        if file_extensions is None:
            file_extensions = ['.exe', '.dll', '.scr', '.bat', '.cmd', '.ps1', '.vbs', '.js', 
                             '.jar', '.docm', '.xlsm', '.pptm', '.zip', '.rar', '.7z']
        
        # Collect files to scan
        files_to_scan = []
        
        if recursive:
            for root, dirs, files in os.walk(directory_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    if any(file.lower().endswith(ext) for ext in file_extensions):
                        files_to_scan.append(file_path)
        else:
            for file in os.listdir(directory_path):
                file_path = os.path.join(directory_path, file)
                if os.path.isfile(file_path) and any(file.lower().endswith(ext) for ext in file_extensions):
                    files_to_scan.append(file_path)
        
        # Parallel scanning for performance
        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
            future_to_file = {executor.submit(self.analyze_file, file_path, False): file_path 
                             for file_path in files_to_scan}
            
            for future in concurrent.futures.as_completed(future_to_file):
                try:
                    detection = future.result()
                    if detection.confidence > 0.3:  # Only include suspicious files
                        detections.append(detection)
                except Exception as e:
                    print(f"Error scanning file {future_to_file[future]}: {e}")
        
        return detections
    
    def _initialize_yara_rules(self):
        """Initialize YARA rules for malware detection."""
        if not YARA_AVAILABLE:
            return
        
        # Create comprehensive YARA rules
        yara_rules_content = r'''
rule Suspicious_PowerShell_Encoded {
    meta:
        description = "Detects suspicious encoded PowerShell commands"
        severity = "HIGH"
        family = "PowerShell_Malware"
    strings:
        $enc1 = "-EncodedCommand" nocase
        $enc2 = "-enc" nocase
        $b64 = /[A-Za-z0-9+\/]{20,}={0,2}/
    condition:
        ($enc1 or $enc2) and $b64
}

rule Ransomware_File_Extension_Changer {
    meta:
        description = "Detects ransomware file extension changing behavior"
        severity = "CRITICAL" 
        family = "Ransomware"
    strings:
        $ext1 = ".locked" nocase
        $ext2 = ".encrypted" nocase
        $ext3 = ".crypto" nocase
        $ext4 = ".crypt" nocase
        $rename = "MoveFileA"
        $rename2 = "MoveFileW"
    condition:
        ($rename or $rename2) and any of ($ext*)
}

rule APT_Lateral_Movement {
    meta:
        description = "Detects APT lateral movement techniques"
        severity = "HIGH"
        family = "APT_Tools"
    strings:
        $psexec = "psexec" nocase
        $wmic = "wmic" nocase
        $cmd1 = "process call create" nocase
        $cmd2 = "\\\\admin$" nocase
        $cmd3 = "\\\\c$" nocase
    condition:
        ($psexec and ($cmd2 or $cmd3)) or ($wmic and $cmd1)
}

rule Suspicious_Registry_Persistence {
    meta:
        description = "Detects suspicious registry persistence mechanisms"
        severity = "MEDIUM"
        family = "Persistence"
    strings:
        $reg1 = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run" nocase
        $reg2 = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce" nocase
        $reg3 = "SYSTEM\\CurrentControlSet\\Services" nocase
        $regwrite = "RegSetValueEx"
    condition:
        $regwrite and any of ($reg*)
}

rule Memory_Injection_Techniques {
    meta:
        description = "Detects memory injection techniques"
        severity = "HIGH"
        family = "Code_Injection"
    strings:
        $api1 = "VirtualAllocEx"
        $api2 = "WriteProcessMemory"
        $api3 = "CreateRemoteThread"
        $api4 = "SetThreadContext"
        $api5 = "ResumeThread"
    condition:
        ($api1 and $api2 and $api3) or ($api4 and $api5)
}

rule Banking_Trojan_Indicators {
    meta:
        description = "Detects banking trojan indicators"
        severity = "HIGH"
        family = "Banking_Trojan"
    strings:
        $url1 = "bank" nocase
        $url2 = "paypal" nocase
        $url3 = "amazon" nocase
        $hook1 = "SetWindowsHookEx"
        $hook2 = "GetMessage"
        $crypto = "CryptProtectData"
    condition:
        ($hook1 and $hook2) and any of ($url*) and $crypto
}

rule Obfuscated_JavaScript {
    meta:
        description = "Detects obfuscated JavaScript malware"
        severity = "MEDIUM"
        family = "JavaScript_Malware"
    strings:
        $js1 = "eval(" nocase
        $js2 = "unescape(" nocase
        $js3 = "fromCharCode(" nocase
        $obf1 = /[a-zA-Z0-9]{100,}/
    condition:
        any of ($js*) and $obf1
}

rule Crypto_Mining_Malware {
    meta:
        description = "Detects cryptocurrency mining malware"
        severity = "MEDIUM"
        family = "Cryptominer"
    strings:
        $pool1 = "stratum+tcp://" nocase
        $pool2 = ".pool." nocase
        $coin1 = "monero" nocase
        $coin2 = "bitcoin" nocase
        $coin3 = "ethereum" nocase
        $miner1 = "xmrig" nocase
        $miner2 = "minerd" nocase
    condition:
        ($pool1 or $pool2) and (any of ($coin*) or any of ($miner*))
}
'''
        
        try:
            # Save rules to temporary file and compile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.yar', delete=False) as f:
                f.write(yara_rules_content)
                temp_rules_file = f.name
            
            self.compiled_rules = yara.compile(filepath=temp_rules_file)
            os.unlink(temp_rules_file)
            
        except Exception as e:
            print(f"Error compiling YARA rules: {e}")
            self.compiled_rules = None
    
    def _load_malware_signatures(self):
        """Load known malware signatures and families."""
        self.malware_signatures = {
            'file_signatures': {
                'wannacry': {
                    'hashes': ['ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa'],
                    'strings': ['tasksche.exe', 'Global\\MsWinZonesCacheCounterMutexA'],
                    'behavior': ['shadow_deletion', 'file_encryption']
                },
                'emotet': {
                    'hashes': ['2ca7b965b52a7e1c8b59b134d18b548f0b5df5d1dba7c5da87a42b3dcb4b1e5e'],
                    'strings': ['%USERPROFILE%', 'CreateRemoteThread'],
                    'behavior': ['email_harvesting', 'process_injection']
                },
                'mirai': {
                    'hashes': ['e29cde24c4dbb7e2b9b46a0db2ea1d6bb3b5c2aaf9a4a2d2ff0c9e1e50e14b49'],
                    'strings': ['/bin/sh', 'telnet', 'busybox'],
                    'behavior': ['brute_force', 'ddos_capability']
                }
            },
            'behavioral_patterns': {
                'ransomware': [
                    'vssadmin delete shadows',
                    'wbadmin delete catalog',
                    'bcdedit /set {default} recoveryenabled no',
                    'cipher /w:'
                ],
                'trojan': [
                    'schtasks /create',
                    'reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
                    'net user /add'
                ],
                'rootkit': [
                    'ntoskrnl.exe',
                    'kernel32.dll',
                    'ZwQuerySystemInformation'
                ]
            }
        }
    
    def _setup_threat_intelligence(self):
        """Setup threat intelligence feeds and databases."""
        self.threat_intelligence = {
            'malware_bazaar': {
                'url': 'https://bazaar.abuse.ch/api/v1/',
                'enabled': True
            },
            'virustotal': {
                'url': 'https://www.virustotal.com/vtapi/v2/',
                'enabled': False,  # Requires API key
                'api_key': None
            },
            'hybrid_analysis': {
                'url': 'https://www.hybrid-analysis.com/api/v2/',
                'enabled': False,  # Requires API key
                'api_key': None
            }
        }
    
    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA256 hash of file."""
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except Exception:
            return ""
    
    def _yara_scan(self, file_path: str) -> Dict:
        """Perform YARA rule scanning."""
        if not YARA_AVAILABLE or not self.compiled_rules:
            return {}
        
        try:
            matches = self.compiled_rules.match(file_path)
            yara_results = []
            
            for match in matches:
                match_info = {
                    'rule': match.rule,
                    'meta': dict(match.meta) if match.meta else {},
                    'strings': [(s.identifier, s.instances) for s in match.strings] if match.strings else [],
                    'tags': match.tags if match.tags else []
                }
                yara_results.append(match_info)
            
            return {'yara_matches': yara_results}
            
        except Exception as e:
            return {'yara_error': str(e)}
    
    def _static_analysis(self, file_path: str) -> Dict:
        """Perform static analysis on the file."""
        analysis_result = {
            'file_type': '',
            'file_size': 0,
            'entropy': 0.0,
            'suspicious_imports': [],
            'suspicious_strings': [],
            'packer_detected': False
        }
        
        try:
            # Get file information
            analysis_result['file_size'] = os.path.getsize(file_path)
            
            # Detect file type
            if magic:
                try:
                    analysis_result['file_type'] = magic.from_file(file_path)
                except:
                    analysis_result['file_type'] = 'Unknown'
            
            # Analyze suspicious strings
            suspicious_strings = self._extract_suspicious_strings(file_path)
            analysis_result['suspicious_strings'] = suspicious_strings
            
        except Exception as e:
            analysis_result['error'] = str(e)
        
        return {'static_analysis': analysis_result}
    
    def _entropy_analysis(self, file_path: str) -> Dict:
        """Calculate entropy to detect packed/encrypted files."""
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            
            if not data:
                return {'entropy': 0.0}
            
            # Calculate Shannon entropy
            byte_counts = Counter(data)
            entropy = 0.0
            
            for count in byte_counts.values():
                if count > 0:
                    probability = count / len(data)
                    entropy -= probability * (probability.bit_length() - 1)
            
            # High entropy (>7.0) suggests encryption/packing
            is_packed = entropy > 7.0
            
            return {
                'entropy': entropy,
                'is_packed': is_packed,
                'packing_confidence': min((entropy - 6.0) / 2.0, 1.0) if entropy > 6.0 else 0.0
            }
            
        except Exception as e:
            return {'entropy_error': str(e)}
    
    def _string_analysis(self, file_path: str) -> Dict:
        """Analyze strings in the file for suspicious content."""
        suspicious_indicators = [
            # Malware-related strings
            'CreateRemoteThread', 'VirtualAllocEx', 'WriteProcessMemory',
            'SetWindowsHookEx', 'GetProcAddress', 'LoadLibrary',
            'RegSetValueEx', 'RegCreateKeyEx', 'RegOpenKeyEx',
            
            # Ransomware indicators
            'YOUR FILES ARE ENCRYPTED', 'PAY BITCOIN', 'RANSOM',
            'DECRYPT', 'RECOVER_FILES', '.locked', '.encrypted',
            
            # Banking trojan indicators
            'bank', 'paypal', 'credit card', 'password', 'login',
            
            # Network communication
            'http://', 'https://', 'ftp://', 'tcp://', 'udp://',
            
            # Cryptocurrency
            'bitcoin', 'monero', 'ethereum', 'mining', 'pool',
            
            # Persistence mechanisms
            'HKEY_LOCAL_MACHINE', 'HKEY_CURRENT_USER', 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'
        ]
        
        found_strings = []
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
            
            # Extract ASCII strings
            ascii_strings = re.findall(b'[ -~]{4,}', content)
            
            for string_bytes in ascii_strings:
                try:
                    string_text = string_bytes.decode('ascii')
                    for indicator in suspicious_indicators:
                        if indicator.lower() in string_text.lower():
                            found_strings.append({
                                'string': string_text,
                                'indicator': indicator,
                                'category': self._categorize_string_indicator(indicator)
                            })
                except:
                    continue
            
        except Exception as e:
            return {'string_analysis_error': str(e)}
        
        return {'suspicious_strings': found_strings}
    
    def _pe_analysis(self, file_path: str) -> Dict:
        """Analyze PE (Portable Executable) files."""
        if not file_path.lower().endswith(('.exe', '.dll', '.scr', '.sys')):
            return {}
        
        pe_analysis = {}
        
        try:
            if 'pefile' in globals():
                pe = pefile.PE(file_path)
                
                pe_analysis = {
                    'imports': [],
                    'exports': [],
                    'sections': [],
                    'resources': [],
                    'suspicious_characteristics': []
                }
                
                # Analyze imports
                if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                    for entry in pe.DIRECTORY_ENTRY_IMPORT:
                        dll_name = entry.dll.decode() if entry.dll else 'Unknown'
                        imports = []
                        for imp in entry.imports:
                            if imp.name:
                                imports.append(imp.name.decode())
                        pe_analysis['imports'].append({
                            'dll': dll_name,
                            'functions': imports
                        })
                
                # Analyze sections
                for section in pe.sections:
                    section_info = {
                        'name': section.Name.decode().strip('\x00'),
                        'virtual_address': hex(section.VirtualAddress),
                        'size': section.SizeOfRawData,
                        'characteristics': section.Characteristics,
                        'entropy': section.get_entropy()
                    }
                    pe_analysis['sections'].append(section_info)
                
                # Check for suspicious characteristics
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0020:  # ASLR disabled
                    pe_analysis['suspicious_characteristics'].append('ASLR disabled')
                
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0100:  # DEP disabled
                    pe_analysis['suspicious_characteristics'].append('DEP disabled')
                
                pe.close()
                
        except Exception as e:
            pe_analysis['pe_error'] = str(e)
        
        return {'pe_analysis': pe_analysis}
    
    def _behavioral_analysis(self, file_path: str) -> Dict:
        """Analyze file for behavioral indicators."""
        behavioral_indicators = []
        
        # Check against known behavioral patterns
        file_name = os.path.basename(file_path).lower()
        
        # Suspicious filenames
        suspicious_names = [
            'svchost.exe', 'winlogon.exe', 'csrss.exe', 'lsass.exe',
            'explorer.exe', 'rundll32.exe', 'regsvr32.exe'
        ]
        
        if file_name in suspicious_names and not self._is_legitimate_system_file(file_path):
            behavioral_indicators.append({
                'indicator': 'suspicious_filename',
                'description': f'File masquerading as system file: {file_name}',
                'confidence': 0.7
            })
        
        # Check file location
        if 'temp' in file_path.lower() or 'appdata' in file_path.lower():
            behavioral_indicators.append({
                'indicator': 'suspicious_location',
                'description': f'File in suspicious location: {file_path}',
                'confidence': 0.5
            })
        
        return {'behavioral_indicators': behavioral_indicators}
    
    def _perform_deep_analysis(self, detection: MalwareDetection):
        """Perform deep analysis including advanced techniques."""
        
        # Threat intelligence lookup
        if detection.file_hash:
            ti_results = self._threat_intelligence_lookup(detection.file_hash)
            if ti_results:
                detection.threat_name = ti_results.get('threat_name', detection.threat_name)
                detection.malware_family = ti_results.get('family', detection.malware_family)
                detection.attribution = ti_results.get('attribution', detection.attribution)
        
        # Advanced pattern matching
        advanced_patterns = self._advanced_pattern_matching(detection.file_path)
        if advanced_patterns:
            detection.behavioral_indicators.extend(advanced_patterns)
        
        # ML-based classification
        ml_classification = self._ml_classification(detection)
        if ml_classification:
            detection.confidence = max(detection.confidence, ml_classification.get('confidence', 0.0))
            if ml_classification.get('family'):
                detection.malware_family = ml_classification['family']
    
    def _calculate_detection_confidence(self, detection: MalwareDetection):
        """Calculate overall detection confidence based on multiple factors."""
        confidence_factors = []
        
        # YARA matches
        if detection.yara_matches:
            yara_confidence = len(detection.yara_matches) * 0.3
            confidence_factors.append(min(yara_confidence, 0.9))
        
        # Static analysis indicators
        if detection.static_analysis:
            if detection.static_analysis.get('suspicious_strings'):
                string_confidence = len(detection.static_analysis['suspicious_strings']) * 0.1
                confidence_factors.append(min(string_confidence, 0.7))
            
            if detection.static_analysis.get('is_packed'):
                confidence_factors.append(0.4)
        
        # Behavioral indicators
        if detection.behavioral_indicators:
            behavioral_confidence = sum(bi.get('confidence', 0.0) for bi in detection.behavioral_indicators) / len(detection.behavioral_indicators)
            confidence_factors.append(behavioral_confidence)
        
        # Calculate overall confidence
        if confidence_factors:
            detection.confidence = min(sum(confidence_factors) / len(confidence_factors), 1.0)
        
        # Determine severity based on confidence and indicators
        if detection.confidence > 0.8:
            detection.severity = "CRITICAL"
        elif detection.confidence > 0.6:
            detection.severity = "HIGH"
        elif detection.confidence > 0.4:
            detection.severity = "MEDIUM"
        else:
            detection.severity = "LOW"
        
        # Set threat name if not already set
        if not detection.threat_name and detection.confidence > 0.5:
            if detection.malware_family:
                detection.threat_name = f"Suspected {detection.malware_family}"
            else:
                detection.threat_name = "Suspicious File"
    
    def _generate_iocs(self, detection: MalwareDetection):
        """Generate Indicators of Compromise (IOCs)."""
        iocs = []
        
        # File hash IOC
        if detection.file_hash:
            iocs.append(f"SHA256: {detection.file_hash}")
        
        # File path IOC
        iocs.append(f"File Path: {detection.file_path}")
        
        # Suspicious strings as IOCs
        if detection.static_analysis and detection.static_analysis.get('suspicious_strings'):
            for string_info in detection.static_analysis['suspicious_strings'][:5]:  # Top 5
                iocs.append(f"String: {string_info.get('string', '')}")
        
        # YARA rule matches as IOCs
        for yara_match in detection.yara_matches:
            iocs.append(f"YARA Rule: {yara_match.get('rule', '')}")
        
        detection.iocs = iocs
    
    def _generate_mitigation_strategies(self, detection: MalwareDetection):
        """Generate mitigation strategies based on detection results."""
        mitigation = []
        
        if detection.severity in ["CRITICAL", "HIGH"]:
            mitigation.extend([
                "Immediately isolate the affected system from the network",
                "Preserve the file for further analysis",
                "Scan all connected systems for similar threats",
                "Review logs for signs of lateral movement"
            ])
        
        if detection.malware_family:
            family_specific = {
                'Ransomware': [
                    "Check for and restore from clean backups",
                    "Do not pay ransom demands", 
                    "Report to law enforcement authorities"
                ],
                'Banking_Trojan': [
                    "Change all banking credentials immediately",
                    "Monitor financial accounts for suspicious activity",
                    "Install additional endpoint protection"
                ],
                'Rootkit': [
                    "Perform low-level system scan",
                    "Consider complete system reimaging",
                    "Update all security software"
                ]
            }
            
            for family, strategies in family_specific.items():
                if family.lower() in detection.malware_family.lower():
                    mitigation.extend(strategies)
        
        if not mitigation:
            mitigation = [
                "Monitor system for suspicious activity",
                "Update antivirus signatures",
                "Apply latest security patches"
            ]
        
        detection.mitigation = mitigation
    
    # Helper methods
    def _merge_detection_results(self, detection: MalwareDetection, result: Dict):
        """Merge analysis results into the detection object."""
        for key, value in result.items():
            if key == 'yara_matches' and value:
                detection.yara_matches.extend(value)
                detection.detection_methods.append('YARA')
            elif key == 'static_analysis':
                detection.static_analysis.update(value)
                detection.detection_methods.append('Static Analysis')
            elif key == 'behavioral_indicators' and value:
                detection.behavioral_indicators.extend(value)
                detection.detection_methods.append('Behavioral Analysis')
    
    def _extract_suspicious_strings(self, file_path: str) -> List[str]:
        """Extract suspicious strings from file."""
        suspicious_strings = []
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read(10000)  # Read first 10KB for performance
            
            # Look for URLs
            url_pattern = rb'https?://[^\s<>"\'`]+'
            urls = re.findall(url_pattern, content)
            suspicious_strings.extend([url.decode('ascii', errors='ignore') for url in urls])
            
            # Look for IP addresses
            ip_pattern = rb'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
            ips = re.findall(ip_pattern, content)
            suspicious_strings.extend([ip.decode('ascii', errors='ignore') for ip in ips])
            
        except Exception:
            pass
        
        return suspicious_strings[:10]  # Return top 10
    
    def _categorize_string_indicator(self, indicator: str) -> str:
        """Categorize string indicators."""
        categories = {
            'API': ['CreateRemoteThread', 'VirtualAllocEx', 'WriteProcessMemory'],
            'Registry': ['HKEY_', 'RegSetValueEx', 'RegCreateKeyEx'],
            'Network': ['http://', 'https://', 'ftp://'],
            'Persistence': ['Run', 'RunOnce', 'schtasks'],
            'Cryptocurrency': ['bitcoin', 'monero', 'ethereum', 'mining']
        }
        
        for category, keywords in categories.items():
            if any(keyword.lower() in indicator.lower() for keyword in keywords):
                return category
        
        return 'General'
    
    def _is_legitimate_system_file(self, file_path: str) -> bool:
        """Check if file is in legitimate system location."""
        system_paths = [
            'c:\\windows\\system32\\',
            'c:\\windows\\syswow64\\',
            'c:\\program files\\',
            'c:\\program files (x86)\\'
        ]
        
        return any(file_path.lower().startswith(path) for path in system_paths)
    
    def _threat_intelligence_lookup(self, file_hash: str) -> Optional[Dict]:
        """Lookup file hash in threat intelligence databases."""
        # This would integrate with real threat intelligence APIs
        # For demo purposes, return sample data for known hashes
        
        known_threats = {
            'ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa': {
                'threat_name': 'WannaCry Ransomware',
                'family': 'Ransomware',
                'attribution': 'Lazarus Group'
            }
        }
        
        return known_threats.get(file_hash)
    
    def _advanced_pattern_matching(self, file_path: str) -> List[Dict]:
        """Advanced pattern matching for sophisticated threats."""
        patterns = []
        
        # Check for obfuscation techniques
        try:
            with open(file_path, 'rb') as f:
                content = f.read(5000)  # First 5KB
            
            # Base64 detection
            base64_pattern = rb'[A-Za-z0-9+/]{20,}={0,2}'
            if re.search(base64_pattern, content):
                patterns.append({
                    'indicator': 'base64_encoding',
                    'description': 'Base64 encoded content detected',
                    'confidence': 0.6
                })
            
            # XOR patterns
            if self._detect_xor_encoding(content):
                patterns.append({
                    'indicator': 'xor_encoding',
                    'description': 'XOR encoding pattern detected',
                    'confidence': 0.7
                })
                
        except Exception:
            pass
        
        return patterns
    
    def _detect_xor_encoding(self, data: bytes) -> bool:
        """Detect XOR encoding patterns."""
        # Simple XOR detection - look for repeated patterns
        if len(data) < 100:
            return False
        
        # Check for single-byte XOR key
        for key in range(1, 256):
            decoded = bytes([b ^ key for b in data[:100]])
            if b'This program' in decoded or b'MZ' in decoded:
                return True
        
        return False
    
    def _ml_classification(self, detection: MalwareDetection) -> Optional[Dict]:
        """Machine learning-based malware classification."""
        # This would integrate with trained ML models
        # For demo purposes, return classification based on simple heuristics
        
        features = []
        
        # Extract features for ML model
        if detection.static_analysis.get('entropy', 0) > 7.0:
            features.append('high_entropy')
        
        if detection.yara_matches:
            features.append('yara_matches')
        
        if detection.behavioral_indicators:
            features.append('behavioral_indicators')
        
        # Simple classification logic
        if len(features) >= 2:
            return {
                'confidence': 0.8,
                'family': 'Unknown_Malware',
                'classification_method': 'ML_Heuristic'
            }
        
        return None
    
    def _analyze_process_for_malware(self, process: Dict) -> Optional[MalwareDetection]:
        """Analyze a process for malware indicators."""
        process_name = process.get('name', '')
        command_line = process.get('command_line', '')
        
        # Create detection object for suspicious process
        detection = MalwareDetection(
            file_path=f"Process: {process_name}",
            file_hash="",
            threat_name=""
        )
        
        # Check for process hollowing
        if 'svchost.exe' in process_name and 'system32' not in command_line.lower():
            detection.behavioral_indicators.append({
                'indicator': 'process_hollowing',
                'description': 'Suspicious svchost.exe not in system32',
                'confidence': 0.8
            })
        
        # Check for suspicious command line arguments
        suspicious_args = ['-enc', '-encodedcommand', '/c echo', 'powershell -w hidden']
        for arg in suspicious_args:
            if arg.lower() in command_line.lower():
                detection.behavioral_indicators.append({
                    'indicator': 'suspicious_arguments',
                    'description': f'Suspicious command line argument: {arg}',
                    'confidence': 0.7
                })
        
        # Calculate confidence
        if detection.behavioral_indicators:
            avg_confidence = sum(bi['confidence'] for bi in detection.behavioral_indicators) / len(detection.behavioral_indicators)
            detection.confidence = avg_confidence
            detection.threat_name = f"Suspicious Process: {process_name}"
            return detection
        
        return None
    
    def _analyze_network_connections(self, connections: List[Dict]) -> List[MalwareDetection]:
        """Analyze network connections for malware indicators."""
        detections = []
        
        for conn in connections:
            remote_ip = conn.get('remote_ip', '')
            remote_port = conn.get('remote_port', 0)
            
            # Check for suspicious ports
            suspicious_ports = [6667, 6668, 6669, 7000, 8080, 9999]
            if remote_port in suspicious_ports:
                detection = MalwareDetection(
                    file_path=f"Network Connection: {remote_ip}:{remote_port}",
                    file_hash="",
                    threat_name=f"Suspicious Network Connection",
                    confidence=0.6
                )
                detection.behavioral_indicators.append({
                    'indicator': 'suspicious_port',
                    'description': f'Connection to suspicious port {remote_port}',
                    'confidence': 0.6
                })
                detections.append(detection)
        
        return detections


# Integration functions
def scan_file_for_malware(file_path: str) -> MalwareDetection:
    """Main function to scan a single file for malware."""
    detector = AdvancedMalwareDetector()
    return detector.analyze_file(file_path)


def scan_directory_for_malware(directory_path: str) -> List[MalwareDetection]:
    """Main function to scan a directory for malware."""
    detector = AdvancedMalwareDetector()
    return detector.scan_directory(directory_path)


def analyze_memory_for_malware(memory_analysis: Dict) -> List[MalwareDetection]:
    """Analyze memory artifacts for malware indicators."""
    detector = AdvancedMalwareDetector()
    return detector.analyze_memory_artifacts(memory_analysis)